import assert from 'assert';
import { Graph } from 'graphlib';
import dot from 'graphlib-dot';
import Viz from '@aduh95/viz.js';

import './graphviz.css';


class GraphvizAdapter {

    viz = new Viz({
        worker: new Worker(new URL("./vizjs-worker.js", import.meta.url), {
            type: "module",
        })
    })
    stylesheet: LayoutStylesheet = {}

    async render(graph: Graph & {dot?: string}) {
        if (this.stylesheet?.graph)
            this.setStyle(graph, this.stylesheet.graph);
        this.setIds(graph);
        let dotText = graph.dot ?? dot.write(graph);
        return new GraphvizSvg(graph,
            this.strip(this.svgElement(await this.viz.renderString(dotText))));
    }

    svgElement(svg: string): SVGSVGElement {
        return <any>(new DOMParser().parseFromString(svg, "image/svg+xml").firstElementChild) as SVGSVGElement;
    }

    setStyle(graph: Graph, props: object) {
        var gl = graph.graph() as any;
        gl = typeof gl === 'string' ? {label: gl} : gl as object;
        graph.setGraph({...gl, ...props});
    }

    /**
     * Sets `id` attributes defaulting to the graphlib ids of the nodes.
     * @param graph 
     */
    setIds(graph: Graph) {
        for (let u of graph.nodes()){
            graph.setNode(u, {id: u, ...graph.node(u)});
        }
    }

    /**
     * Removes inline styling -- allowing elements to be styled by CSS.
     * @param svg 
     * @returns 
     */
    strip<E extends SVGElement>(svg: E) {
        for (let el of svg.querySelectorAll('[stroke],[fill]')) {
            el.removeAttribute('stroke');
            el.removeAttribute('fill');
        }
        return svg;
    }
}

type LayoutStylesheet = {
    graph?: {ranksep?: number | string, nodesep?: number | string}
}

class GraphvizSvg {
    graph: Graph
    svg: SVGSVGElement

    constructor(graph: Graph, svg: SVGSVGElement) {
        this.graph = graph;
        this.svg = svg;
    }

    nodeFromElement(el: SVGElement) {
        let node = el.closest('.node,.cluster');
        if (node) {
            let id = this.idFromElement(node);
            return this.graph.node(id) ?? 
                   this.graph.node(`cluster_${id}`);
        }
        else return undefined;
    }

    idFromElement(el: Element) {
        // a bit ad-hoc. `<title>` contains the id; if the node also has
        // an `id` attribute, then that one is inserted in the `id`
        // attribute of the element. otherwise `id` contains autogenerated ids.
        return el.querySelector('title').textContent || el.id;
    }

    elementFromNode(node: NodeRef) {
        let id = typeof node === 'object' ? node.id : node;
        assert(id);
        for (let {el, node} of this.iterNodeElements()) {
            if (node.id == id) return el;
        }
    }

    elementFromEdge(from: NodeRef, to: NodeRef) {
        let id = (o: NodeRef) => typeof o === 'object' ? o.id : o,
            expected = `${id(from)}->${id(to)}`;

        for (let {el, title} of this.iterEdgeElements()) {
            if (title === expected) return el;
        }
    }

    *iterNodeElements() {
        for (let el of this.svg.querySelectorAll('.node,.cluster')) {
            let node = this.nodeFromElement(el as SVGElement);
            if (node) yield {el, node};
        }
    }

    *iterEdgeElements() {
        for (let el of this.svg.querySelectorAll('.edge')) {
            let title = el.querySelector('title')?.textContent;
            if (title) yield {el, title};
        }
    }
}

type NodeRef = number | string | {id: string};


export { GraphvizAdapter, GraphvizSvg }
export type { NodeRef }